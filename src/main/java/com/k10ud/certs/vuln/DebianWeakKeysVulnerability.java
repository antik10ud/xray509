/*
 * Copyright (c) 2019 David Castañón <antik10ud@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

package com.k10ud.certs.vuln;

import com.k10ud.certs.IOUtil;
import com.k10ud.certs.util.BloomFilter;

import java.io.InputStream;
import java.math.BigInteger;
import java.security.PublicKey;
import java.security.interfaces.RSAPublicKey;
import java.util.Arrays;

public class DebianWeakKeysVulnerability {


    public enum Result {Unknown, Affected, NotAffected}

    private static BloomFilter bf;
    private static boolean initilized;

    public static void init() {
        try (InputStream is = DebianWeakKeysVulnerability.class.getResourceAsStream("/weakkeys.bloom")) {
            bf = BloomFilter.read(IOUtil.readAllBytes(is));
            initilized = true;
        } catch (Exception e) {
            //...
            bf = new BloomFilter(1, 0.1);
        }
    }

    public static Result isAffected(PublicKey pk) {
        if (bf == null)
            init();

        if (!initilized)
            return Result.Unknown;

        if (!(pk instanceof RSAPublicKey))
            return Result.Unknown;

        BigInteger modulus = ((RSAPublicKey) pk).getModulus();
        byte[] mod = modulus.toByteArray();
        byte[] k = Arrays.copyOfRange(mod, mod.length - 16, mod.length);
        for (int i = 0, j = k.length - 1; j > i; j--, i++) {
            byte b = k[i];
            k[i] = k[j];
            k[j] = b;
        }
        if (!bf.test(k))
            return Result.NotAffected;

        return search(k);
    }

    private static Result search(byte[] key) {
        try (InputStream is = DebianWeakKeysVulnerability.class.getResourceAsStream("/weakkeys.data")) {
            byte[] r = IOUtil.readAllBytes(is);
            return search(key, r);
        } catch (Exception e) {
            return Result.Unknown;
        }
    }

    static Result search(byte[] key, byte[] r) {
        try {
            int CHK = key.length;
            int z = 0;
            int n = (r.length / CHK) - 1;
            int mxv = 0;
            next:
            while (true) {
                if (z > n)
                    return Result.NotAffected;

                for (int v = 0, i = z + ((n - z) >> 1), a = i * CHK, b = a + CHK; a < b; v++, a++) {

                    if (key[v] != r[a]) {

                        if ((key[v] & 0xff) > (r[a] & 0xff))
                            z = i + 1;
                        else
                            n = i - 1;

                        continue next;
                    }

                }
                return Result.Affected;
            }
        } catch (Exception e) {
            return Result.Unknown;
        }
    }


}
